"use strict";(self.webpackChunkflowmap_gl_docs=self.webpackChunkflowmap_gl_docs||[]).push([[927],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},g=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=c(n),g=r,m=u["".concat(s,".").concat(g)]||u[g]||d[g]||l;return n?a.createElement(m,o(o({ref:t},p),{},{components:n})):a.createElement(m,o({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,o=new Array(l);o[0]=g;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[u]="string"==typeof e?e:r,o[1]=i;for(var c=2;c<l;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}g.displayName="MDXCreateElement"},4902:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>l,metadata:()=>i,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const l={sidebar_position:4},o="TypeScript Types",i={unversionedId:"api/types",id:"api/types",title:"TypeScript Types",description:"This page documents the main TypeScript types used in flowmap.gl.",source:"@site/docs/api/types.md",sourceDirName:"api",slug:"/api/types",permalink:"/docs/api/types",draft:!1,editUrl:"https://github.com/visgl/flowmap.gl-docs/docs/api/types.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"docsSidebar",previous:{title:"Clustering",permalink:"/docs/api/clustering"},next:{title:"FAQ",permalink:"/docs/faq"}},s={},c=[{value:"Core Data Types",id:"core-data-types",level:2},{value:"FlowmapData",id:"flowmapdata",level:3},{value:"ViewState",id:"viewstate",level:3},{value:"ViewportProps",id:"viewportprops",level:3},{value:"Accessor Types",id:"accessor-types",level:2},{value:"LocationAccessors",id:"locationaccessors",level:3},{value:"FlowAccessors",id:"flowaccessors",level:3},{value:"FlowmapDataAccessors",id:"flowmapdataaccessors",level:3},{value:"State Types",id:"state-types",level:2},{value:"FilterState",id:"filterstate",level:3},{value:"LocationFilterMode",id:"locationfiltermode",level:3},{value:"SettingsState",id:"settingsstate",level:3},{value:"FlowmapState",id:"flowmapstate",level:3},{value:"Picking Types",id:"picking-types",level:2},{value:"PickingType",id:"pickingtype",level:3},{value:"LocationTotals",id:"locationtotals",level:3},{value:"FlowmapLayerPickingInfo",id:"flowmaplayerpickinginfo",level:3},{value:"Clustering Types",id:"clustering-types",level:2},{value:"ClusterNode",id:"clusternode",level:3},{value:"Cluster",id:"cluster",level:3},{value:"ClusterLevel",id:"clusterlevel",level:3},{value:"ClusterLevels",id:"clusterlevels",level:3},{value:"Type Guard Functions",id:"type-guard-functions",level:3},{value:"Aggregate Types",id:"aggregate-types",level:2},{value:"AggregateFlow",id:"aggregateflow",level:3},{value:"Type Guard",id:"type-guard",level:3},{value:"Layer Attribute Types",id:"layer-attribute-types",level:2},{value:"FlowCirclesLayerAttributes",id:"flowcircleslayerattributes",level:3},{value:"FlowLinesLayerAttributes",id:"flowlineslayerattributes",level:3},{value:"LayersData",id:"layersdata",level:3},{value:"LayersDataAttrValues",id:"layersdataattrvalues",level:3},{value:"Usage Example",id:"usage-example",level:2}],p={toc:c};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"typescript-types"},"TypeScript Types"),(0,r.kt)("p",null,"This page documents the main TypeScript types used in flowmap.gl."),(0,r.kt)("h2",{id:"core-data-types"},"Core Data Types"),(0,r.kt)("h3",{id:"flowmapdata"},"FlowmapData"),(0,r.kt)("p",null,"The main data structure for the FlowmapLayer:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"interface FlowmapData<L, F> {\n  locations: Iterable<L>;           // Array or iterable of locations\n  flows: Iterable<F>;               // Array or iterable of flows\n  clusterLevels?: ClusterLevels;    // Optional pre-computed clusters\n}\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Type Parameters:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"L")," - The shape of your location objects"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"F")," - The shape of your flow objects")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"interface MyLocation {\n  id: string;\n  name: string;\n  lat: number;\n  lon: number;\n}\n\ninterface MyFlow {\n  origin: string;\n  dest: string;\n  count: number;\n}\n\nconst data: FlowmapData<MyLocation, MyFlow> = {\n  locations: [...],\n  flows: [...],\n};\n")),(0,r.kt)("h3",{id:"viewstate"},"ViewState"),(0,r.kt)("p",null,"Viewport state for map positioning:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"interface ViewState {\n  latitude: number;\n  longitude: number;\n  zoom: number;\n  bearing?: number;\n  pitch?: number;\n  altitude?: number;\n}\n")),(0,r.kt)("h3",{id:"viewportprops"},"ViewportProps"),(0,r.kt)("p",null,"Extended viewport properties:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"interface ViewportProps {\n  width: number;\n  height: number;\n  latitude: number;\n  longitude: number;\n  zoom?: number;\n  bearing?: number;\n  pitch?: number;\n  altitude?: number;\n  maxZoom?: number;\n  minZoom?: number;\n  maxPitch?: number;\n  minPitch?: number;\n  transitionDuration?: number | 'auto';\n  transitionInterpolator?: any;\n  transitionInterruption?: any;\n  transitionEasing?: any;\n}\n")),(0,r.kt)("h2",{id:"accessor-types"},"Accessor Types"),(0,r.kt)("h3",{id:"locationaccessors"},"LocationAccessors"),(0,r.kt)("p",null,"Functions to extract data from location objects:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"interface LocationAccessors<L> {\n  getLocationId: (location: L) => string | number;\n  getLocationLat: (location: L) => number;\n  getLocationLon: (location: L) => number;\n  getLocationName?: (location: L) => string;\n  getLocationClusterName?: (locationIds: (string | number)[]) => string;\n}\n")),(0,r.kt)("h3",{id:"flowaccessors"},"FlowAccessors"),(0,r.kt)("p",null,"Functions to extract data from flow objects:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"interface FlowAccessors<F> {\n  getFlowOriginId: (flow: F) => string | number;\n  getFlowDestId: (flow: F) => string | number;\n  getFlowMagnitude: (flow: F) => number;\n  getFlowTime?: (flow: F) => Date;\n}\n")),(0,r.kt)("h3",{id:"flowmapdataaccessors"},"FlowmapDataAccessors"),(0,r.kt)("p",null,"Combined accessors:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"type FlowmapDataAccessors<L, F> = LocationAccessors<L> & FlowAccessors<F>;\n")),(0,r.kt)("h2",{id:"state-types"},"State Types"),(0,r.kt)("h3",{id:"filterstate"},"FilterState"),(0,r.kt)("p",null,"Filter configuration:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"interface FilterState {\n  selectedLocations?: (string | number)[];\n  locationFilterMode?: LocationFilterMode;\n  selectedTimeRange?: [Date, Date];\n}\n")),(0,r.kt)("h3",{id:"locationfiltermode"},"LocationFilterMode"),(0,r.kt)("p",null,"Enum for filtering flows by location:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"enum LocationFilterMode {\n  ALL = 'ALL',           // Show all flows\n  INCOMING = 'INCOMING', // Only flows to selected locations\n  OUTGOING = 'OUTGOING', // Only flows from selected locations\n  BETWEEN = 'BETWEEN',   // Flows between selected locations\n}\n")),(0,r.kt)("h3",{id:"settingsstate"},"SettingsState"),(0,r.kt)("p",null,"Display settings:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"interface SettingsState {\n  animationEnabled: boolean;\n  fadeEnabled: boolean;\n  fadeOpacityEnabled: boolean;\n  locationsEnabled: boolean;\n  locationTotalsEnabled: boolean;\n  locationLabelsEnabled: boolean;\n  adaptiveScalesEnabled: boolean;\n  clusteringEnabled: boolean;\n  clusteringAuto: boolean;\n  clusteringLevel?: number;\n  darkMode: boolean;\n  fadeAmount: number;\n  colorScheme: string | string[] | undefined;\n  highlightColor: string;\n  maxTopFlowsDisplayNum: number;\n}\n")),(0,r.kt)("h3",{id:"flowmapstate"},"FlowmapState"),(0,r.kt)("p",null,"Complete state combining filter, settings, and viewport:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"interface FlowmapState {\n  filter?: FilterState;\n  settings: SettingsState;\n  viewport: ViewportProps;\n}\n")),(0,r.kt)("h2",{id:"picking-types"},"Picking Types"),(0,r.kt)("h3",{id:"pickingtype"},"PickingType"),(0,r.kt)("p",null,"Enum identifying what was picked:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"enum PickingType {\n  LOCATION = 'location',\n  FLOW = 'flow',\n}\n")),(0,r.kt)("h3",{id:"locationtotals"},"LocationTotals"),(0,r.kt)("p",null,"Aggregated flow totals for a location:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"interface LocationTotals {\n  incomingCount: number;   // Total flow into location\n  outgoingCount: number;   // Total flow out of location\n  internalCount: number;   // Internal/self flows\n}\n")),(0,r.kt)("h3",{id:"flowmaplayerpickinginfo"},"FlowmapLayerPickingInfo"),(0,r.kt)("p",null,"Information returned by onHover and onClick:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// For location picks\ninterface LocationPickingInfo<L> {\n  type: PickingType.LOCATION;\n  location: L;\n  id: string | number;\n  name: string;\n  totals: LocationTotals;\n  circleRadius: number;\n  // Plus standard deck.gl picking info: x, y, coordinate, etc.\n}\n\n// For flow picks\ninterface FlowPickingInfo<L, F> {\n  type: PickingType.FLOW;\n  flow: F;\n  origin: L;\n  dest: L;\n  count: number;\n  // Plus standard deck.gl picking info: x, y, coordinate, etc.\n}\n\ntype FlowmapLayerPickingInfo<L, F> = LocationPickingInfo<L> | FlowPickingInfo<L, F>;\n")),(0,r.kt)("h2",{id:"clustering-types"},"Clustering Types"),(0,r.kt)("h3",{id:"clusternode"},"ClusterNode"),(0,r.kt)("p",null,"Base type for all nodes in cluster hierarchy:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"interface ClusterNode {\n  id: string | number;\n  zoom: number;\n  lat: number;\n  lon: number;\n}\n")),(0,r.kt)("h3",{id:"cluster"},"Cluster"),(0,r.kt)("p",null,"A cluster containing multiple locations:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"interface Cluster extends ClusterNode {\n  name?: string;\n  children: (string | number)[];  // Child location/cluster IDs\n}\n")),(0,r.kt)("h3",{id:"clusterlevel"},"ClusterLevel"),(0,r.kt)("p",null,"One level of clustering at a specific zoom:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"interface ClusterLevel {\n  zoom: number;\n  nodes: ClusterNode[];\n}\n")),(0,r.kt)("h3",{id:"clusterlevels"},"ClusterLevels"),(0,r.kt)("p",null,"Array of cluster levels:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"type ClusterLevels = ClusterLevel[];\n")),(0,r.kt)("h3",{id:"type-guard-functions"},"Type Guard Functions"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// Check if a ClusterNode is actually a Cluster\nfunction isCluster(c: ClusterNode): c is Cluster {\n  const {children} = c as Cluster;\n  return children && children.length > 0;\n}\n\n// Check if a location is a ClusterNode\nfunction isLocationClusterNode<L>(l: L | ClusterNode): l is ClusterNode {\n  const {zoom} = l as ClusterNode;\n  return zoom !== undefined;\n}\n")),(0,r.kt)("h2",{id:"aggregate-types"},"Aggregate Types"),(0,r.kt)("h3",{id:"aggregateflow"},"AggregateFlow"),(0,r.kt)("p",null,"A flow aggregated from multiple source flows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"interface AggregateFlow {\n  origin: string | number;\n  dest: string | number;\n  count: number;\n  aggregate: true;\n}\n")),(0,r.kt)("h3",{id:"type-guard"},"Type Guard"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"function isAggregateFlow(flow: Record<string, any>): flow is AggregateFlow {\n  return flow && flow.aggregate === true;\n}\n")),(0,r.kt)("h2",{id:"layer-attribute-types"},"Layer Attribute Types"),(0,r.kt)("p",null,"These are internal types used by the rendering layers:"),(0,r.kt)("h3",{id:"flowcircleslayerattributes"},"FlowCirclesLayerAttributes"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"interface FlowCirclesLayerAttributes {\n  length: number;\n  attributes: {\n    getPosition: LayersDataAttrValues<Float32Array>;\n    getColor: LayersDataAttrValues<Uint8Array>;\n    getInRadius: LayersDataAttrValues<Float32Array>;\n    getOutRadius: LayersDataAttrValues<Float32Array>;\n  };\n}\n")),(0,r.kt)("h3",{id:"flowlineslayerattributes"},"FlowLinesLayerAttributes"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"interface FlowLinesLayerAttributes {\n  length: number;\n  attributes: {\n    getSourcePosition: LayersDataAttrValues<Float32Array>;\n    getTargetPosition: LayersDataAttrValues<Float32Array>;\n    getThickness: LayersDataAttrValues<Float32Array>;\n    getColor: LayersDataAttrValues<Uint8Array>;\n    getEndpointOffsets: LayersDataAttrValues<Float32Array>;\n    getStaggering?: LayersDataAttrValues<Float32Array>;\n  };\n}\n")),(0,r.kt)("h3",{id:"layersdata"},"LayersData"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"interface LayersData {\n  circleAttributes: FlowCirclesLayerAttributes;\n  lineAttributes: FlowLinesLayerAttributes;\n  locationLabels?: string[];\n}\n")),(0,r.kt)("h3",{id:"layersdataattrvalues"},"LayersDataAttrValues"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"type LayersDataAttrValues<T> = {\n  value: T;\n  size: number;\n};\n")),(0,r.kt)("h2",{id:"usage-example"},"Usage Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import {\n  FlowmapLayer,\n  FlowmapLayerPickingInfo,\n  PickingType,\n} from '@flowmap.gl/layers';\n\nimport {\n  FlowmapData,\n  FilterState,\n  LocationFilterMode,\n  ViewState,\n} from '@flowmap.gl/data';\n\n// Define your data types\ninterface Location {\n  id: string;\n  name: string;\n  lat: number;\n  lon: number;\n}\n\ninterface Flow {\n  origin: string;\n  dest: string;\n  count: number;\n}\n\n// Type-safe data\nconst data: FlowmapData<Location, Flow> = {\n  locations: [...],\n  flows: [...],\n};\n\n// Type-safe filter\nconst filter: FilterState = {\n  selectedLocations: ['NYC', 'LA'],\n  locationFilterMode: LocationFilterMode.BETWEEN,\n};\n\n// Type-safe layer\nconst layer = new FlowmapLayer<Location, Flow>({\n  data,\n  filter,\n  // TypeScript enforces correct accessor signatures\n  getLocationId: (loc) => loc.id,\n  getLocationLat: (loc) => loc.lat,\n  getLocationLon: (loc) => loc.lon,\n  getFlowOriginId: (flow) => flow.origin,\n  getFlowDestId: (flow) => flow.dest,\n  getFlowMagnitude: (flow) => flow.count,\n\n  // Type-safe event handler\n  onHover: (info: FlowmapLayerPickingInfo<Location, Flow> | undefined) => {\n    if (info?.object?.type === PickingType.LOCATION) {\n      console.log(info.object.name);  // TypeScript knows this exists\n    }\n  },\n});\n")))}u.isMDXComponent=!0}}]);